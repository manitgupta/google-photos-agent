sources:
  social-graph-spanner-source:
    kind: spanner
    project: terraform-demo-service
    instance: google-photos-instance
    database: google-photos

tools:
  find_ranked_photos:
    kind: spanner-sql
    source: social-graph-spanner-source
    description: "Finds and ranks photos based on who appears in them, with a required minimum number of people present. Can be used for both strict ('A and B') and ranked ('family') searches."
    parameters:
      - { name: user_name, type: string, description: "The name of the user who owns the photos." }
      - { name: target_person_names, type: string, description: "A comma-separated string of names of people to search for." }
      - { name: minimum_match_count, type: string, description: "The minimum number of people from the list that must appear in a photo for it to be returned." }
      - { name: location, type: string, description: "The location to search for. Use '%' to match any location." }
      - { name: start_time, type: string, description: "The start timestamp for the search range." }
      - { name: end_time, type: string, description: "The end timestamp for the search range." }
    statement: |
      SELECT
        p.photo_location
      FROM
        Person AS u
      JOIN PersonOwnsPhoto AS pop ON u.person_id = pop.person_id
      JOIN Photo AS p ON pop.photo_id = p.photo_id
      JOIN PersonAppearsInPhoto AS paip ON p.photo_id = paip.photo_id
      JOIN Person AS appears ON paip.person_id = appears.person_id
      WHERE
        u.name = @user_name
        AND appears.name IN UNNEST(SPLIT(@target_person_names, ','))
        AND p.location_name LIKE @location
        AND p.timestamp BETWEEN @start_time AND @end_time
      GROUP BY
        p.photo_id, p.photo_location, p.timestamp
      HAVING
        COUNT(DISTINCT appears.person_id) >= CAST(@minimum_match_count AS INT64)
      ORDER BY
        COUNT(DISTINCT appears.person_id) DESC,
        p.timestamp DESC;

  find_photos_by_metadata:
    kind: spanner-sql
    source: social-graph-spanner-source
    description: "Use this tool ONLY when the user is searching for photos by location and/or time, and has NOT mentioned any people, friends, or family."
    parameters:
      - { name: user_name, type: string, description: "The name of the user who owns the photos." }
      - { name: location, type: string, description: "The location to search for. Use '%' to match any location." }
      - { name: start_time, type: string, description: "The start timestamp for the search range." }
      - { name: end_time, type: string, description: "The end timestamp for the search range." }
    statement: |
      SELECT p.photo_location
      FROM Person AS u
      JOIN PersonOwnsPhoto AS pop ON u.person_id = pop.person_id
      JOIN Photo AS p ON pop.photo_id = p.photo_id
      WHERE
        u.name = @user_name
        AND p.location_name LIKE @location
        AND p.timestamp BETWEEN @start_time AND @end_time
      ORDER BY
        p.timestamp DESC;

  find_relationships_by_type:
    kind: spanner-sql
    source: social-graph-spanner-source
    description: "Find the names of people who have a specific relationship type with the user."
    parameters:
      - { name: user_name, type: string, description: "The name of the user." }
      - { name: relationship_type, type: string, description: "The type of relationship (e.g., 'FRIEND', 'FAMILY')." }
    statement: |
      SELECT p2.name AS person_name
      FROM Person AS p1
      JOIN PersonRelationships AS pr ON p1.person_id = pr.person1_id
      JOIN Person AS p2 ON pr.person2_id = p2.person_id
      WHERE p1.name = @user_name AND pr.relationship_type = @relationship_type
      UNION ALL
      SELECT p1.name AS person_name
      FROM Person AS p2
      JOIN PersonRelationships AS pr ON p2.person_id = pr.person2_id
      JOIN Person AS p1 ON pr.person1_id = p1.person_id
      WHERE p2.name = @user_name AND pr.relationship_type = @relationship_type;

toolsets:
  social_profiling_toolset:
    - find_ranked_photos
    - find_photos_by_metadata
    - find_relationships_by_type

